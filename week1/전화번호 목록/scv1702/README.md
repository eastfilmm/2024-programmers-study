# 문제 풀이

## 문제 해설

번호 목록이 주어지고 어떤 번호가 다른 번호의 접두어인 경우가 존재하는지 판단하는 문제다. 다만 주의할 점은 데이터의 크기가 10^6인 점이다. 문제는 단순하기 때문에 2중 `for` 문을 사용한다면 쉽게 풀지 않을까 생각할 수 있지만 데이터의 크기가 때문에 이는 불가능하다. 데이터의 크기가 10^6 이므로 각 문자열마다 `O(1)`에 준하는 수준으로 판단을 해야 한다. 

필자는 먼저 각 번호의 길이가 최대 20이라는 점에 주목했다. 번호의 길이가 짧기 때문에 전화번호 `phone`에 대해 접두어의 모든 경우의 수는 최대 20이다. 또한 데이터의 크기가 매우 크다는 점에서 해시 테이블을 1차적으로 떠올렸다. 해시 테이블의 시간 복잡도는 `O(1)`이므로 데이터의 크기가 클때 자주 사용되기 때문이다. 해시 테이블에 번호를 저장해둔다면 어떤 번호의 접두어와 해시 테이블에 저장된 번호의 일치 유무에 대해 `O(1)`만에 가능하다. 또한 번호의 접두어가 최대 20이므로 한 번호에 대해 판단하는 시간은 `O(20)`으로 상수 시간이다.

그러나 접두어의 모든 경우의 수를 비교하기 위해선 번호의 길이가 짧은 순으로 비교를 해야 한다. 왜냐하면 어떤 번호에 대해 자신이 해시 테이블에 저장된 번호를 접두어로 포함하는지는 판단이 가능하지만 반대는 불가능하기 때문이다. 예를 들어 `["12345", "123"]`의 경우 번호 `"12345"`가 `"123"`을 포함하고 있지만, 이는 판단할 수 없다.

## 시간 복잡도

본 문제는 크게 처음에 번호의 길이에 대해 정렬을 하는 과정과 어떤 번호의 모든 접두어에 대해 해시 테이블에 있는 번호와 비교하는 과정, 마지막에 해시 테이블에 번호를 저장하는 과정으로 나뉜다. 번호의 길이가 최대 20이지만 이를 `s`라고 하고, `phoneBook`의 길이를 `n`이라고 할때 정렬은 `O(ns + nlog(n))`이 된다. 접두어를 비교하는 과정은 모든 번호에 대해 `O(s)`를 수행하므로 `O(ns)`가 된다. 대부분의 경우 `n > s`이기 때문에, 전체 시간 복잡도는 `O(nlog(n))`이라고 할 수 있다.

```java
import java.util.*;

class Solution {
    public boolean solution(String[] phoneBook) {
        Map<String, String> map = new HashMap<>();
        Arrays.sort(phoneBook, (String s1, String s2) -> s1.length() - s2.length());
        for (String phone: phoneBook) {
            StringBuilder sb = new StringBuilder();
            for (int i = 0; i < phone.length(); i++) {
                String key = sb.append(phone.charAt(i)).toString();
                if (map.containsKey(key)) {
                    return false;
                }
            }
            map.put(phone, phone);
        }
        return true;
    }
}
```